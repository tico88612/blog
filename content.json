{"meta":{"title":"Jerry Yang's Blog","subtitle":null,"description":null,"author":"Jerry Yang","url":"http://blog.yangjerry.tw"},"pages":[],"posts":[{"title":"d708. 小王的积木","slug":"zj-d708","date":"2018-09-02T07:35:37.000Z","updated":"2018-09-02T11:08:57.753Z","comments":true,"path":"2018/09/02/zj-d708/","link":"","permalink":"http://blog.yangjerry.tw/2018/09/02/zj-d708/","excerpt":"題目 Problem題目連結：https://zerojudge.tw/ShowProblem?problemid=d708","text":"題目 Problem題目連結：https://zerojudge.tw/ShowProblem?problemid=d708 敘述 Description自从小涵去商店买了那么多的积木，小王也去买了一大堆。不过小王比较喜欢数学，所以他买的积木上写的只有数字；因为他认为偶数比较吉利，于是他买的积木是全是偶数快的。听说小涵少了一个积木，他便整理了一下他的，可是他发现他也少了一块积木…（很无语吧…）上次他见你已经帮小涵找到了积木，于是就请你来帮他找找，而且他还告诉你：“我的积木比小涵的好找很多。”半信半疑的你决定帮帮他。 輸入 Input只有一笔测资。 测资末尾会有多余信息，忽略就好。//感谢asas提醒。2015/8/6 输入数据的第一行，是小王告诉你他的积木个数N（N一定是一个正偶数，而且2&lt;=N&lt;=1000000，你看他的积木可没有小涵的多）。接下来每行有（N-1）个数字，表示小王每个积木上的数字（可以用longint存储）。 輸出 Output对于每组测资，输出小王缺少的那块积木的数字。 範例輸入 Sample Input1234567881232344 範例輸出 Sample Output11 提示 Hint提示 ：小涵的积木的AC代码可以直接AC本题。但我希望您可以想想另一种解答方式，想想数字有什么特殊性，参考时间复杂度$O(n)$，空间复杂度$O(1)$。 还有一种算法时间复杂度$O(n\\log{n})$，空间复杂度$O(n)$的… 如果哪种语言直接输入都超时的话，请与我联系，我将调整时间限制。 //感谢ck99126指出题目存在的一些问题！ 題解 Solution1.直接暴力做無庸置疑，跟 C++ Map 一起使用 程式碼 I Accepted Code I123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;#define _ ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);using namespace std;int main()&#123; _ long long int N; cin&gt;&gt;N; map&lt;int,int&gt; m; long long int A; for(int i=0;i&lt;N-1;i++)&#123; cin&gt;&gt;A; map&lt;int,int&gt;::iterator it=m.find(A); if(it==m.end()) m[A]=1; else m[A]++; &#125; for(auto it=m.begin();it!=m.end();it++) if(it-&gt;second%2)&#123; cout&lt;&lt;it-&gt;first&lt;&lt;'\\n'; break; &#125; return 0;&#125; 2.XORc651. 三、區間xor(RXQ) 這篇文章有寫過有關 XOR 的性質用歸零律跟自反性就可以完成了程式碼 II Accepted Code II123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;#define _ ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);using namespace std;int main()&#123; _ long long int N; cin&gt;&gt;N; map&lt;int,int&gt; m; long long int A; for(int i=0;i&lt;N-1;i++)&#123; cin&gt;&gt;A; map&lt;int,int&gt;::iterator it=m.find(A); if(it==m.end()) m[A]=1; else m[A]++; &#125; for(auto it=m.begin();it!=m.end();it++) if(it-&gt;second%2)&#123; cout&lt;&lt;it-&gt;first&lt;&lt;'\\n'; break; &#125; return 0;&#125; 後記 Afterword很神奇吧，這樣複雜度都壓下去了但後面有些東西是用HTML補上去的不曉得是不是 Hexo 出 BUG 了有些正常的 Markdown 無法解析成功就這樣吧","categories":[{"name":"解題區","slug":"解題區","permalink":"http://blog.yangjerry.tw/categories/解題區/"},{"name":"解題報告書 - ZeroJugde","slug":"解題區/解題報告書-ZeroJugde","permalink":"http://blog.yangjerry.tw/categories/解題區/解題報告書-ZeroJugde/"}],"tags":[{"name":"XOR","slug":"XOR","permalink":"http://blog.yangjerry.tw/tags/XOR/"}]},{"title":"c651. 三、區間xor(RXQ)","slug":"zj-c651","date":"2018-09-01T16:41:17.000Z","updated":"2018-09-02T09:39:57.626Z","comments":true,"path":"2018/09/02/zj-c651/","link":"","permalink":"http://blog.yangjerry.tw/2018/09/02/zj-c651/","excerpt":"題目 Problem題目連結：https://zerojudge.tw/ShowProblem?problemid=c651","text":"題目 Problem題目連結：https://zerojudge.tw/ShowProblem?problemid=c651 敘述 Description給你一段 $N$ 個正整數的序列 $a_1∼a_N$ ，請你執行 $Q$ 筆操作。 輸入 Input第一行有兩個正整數 $N,Q$ 。 第二行有 $N$ 個非負整數 $a_i$ 。 接下來有 $Q$ 行，每行代表一個操作。 如果是 $0\\ l\\ r$ ，代表詢問 $[l,r]$ 區間的每個數字做 $xor$ 運算之後的值。 如果是 $1\\ x\\ v$ ，代表將 $a_x$ 置換成 $v$ 。 ※ $xor$ 即代表C++中的位元運算「^」。 輸出 Output對於每個詢問，輸出詢問區間的每個數字做 $xor$ 運算之後的值。 範例輸入 Sample Input123455 316 9 1 5 30 1 51 1 50 1 5 範例輸出 Sample Output123011 提示 Hint本題共有四組測試題組，條件限制如下所示。每一組可有一或多筆測試資料，該組所有測試資料皆需答對才會獲得該組分數。cout &lt;&lt; (16^9^1^5^3) &lt;&lt; “\\n”; 輸出即為30。 觀察一下 xor 的性質，不然這題拿不滿XD。輸入卡很緊，記得加優化。 題解 Solution遇到一般的RMQ+單點修改問題，通常有幾種解題方式 線段樹 Segment Tree 二元索引樹（樹狀樹组） Binary Index Tree (Fenwick tree)不過這題時限只有$0.5$秒如果用前綴 $XOR$ 單點修改變成$O(N)$如果用線段樹遞迴查詢可能會有點慢（有實做過，只有$72\\%$，其他的被TLE） 這題可以使用BIT，也就是二元索引樹，但要如何使用呢？（以下把二元索引樹 簡稱 BIT） XOR 真值表＆性質 $A$ $B$ $A⊕B$ $0$ $0$ $0$ $1$ $0$ $1$ $0$ $1$ $1$ $1$ $1$ $0$ 恆等律：$X⊕0=X$歸零律：$X⊕X=0$自反性：$A⊕B⊕B=A⊕(B⊕B)=A⊕0=A$ 其中的歸零律跟自反性就是我們要使用的 拿到BIT的模板應該都是求區間和 假設我們要求$[L,R]$的區間和是不是只要$sum(R)-sum(L-1)$？ 這題改成區間 XORBIT 初始化就改成 XOR（程式碼 Line 15）然後把求前綴和的 $+$ 改成 XOR（程式碼 Line 9）就變成 前綴 XOR 了 查詢只要輸出 $xxor(R)⊕xxor(L-1)$（程式碼 Line 37） 單點修改呢？先把原本的數字跟要變成的數字做 XOR 變成 $val$（程式碼 Line 40）利用歸零律跟自反性後面需要更新的數字，統一跟 $val$ 做 XOR單點修改就完成了 程式碼 Accepted Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#define _ ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);#define lowbit(x) ((x)&amp;(-x))using namespace std;const int MAXN = 1000000+2;int Origin[MAXN+1]=&#123;0&#125;;int BITS[MAXN+1]=&#123;0&#125;;int N,Q;int xxor(int x)&#123; int ans=0; for(;x;x-=lowbit(x)) ans^=BITS[x]; return ans;&#125;void init(int n) &#123; for(int x = 1; x &lt;= n; ++x) &#123; BITS[x] = Origin[x]; int y = x - lowbit(x); for(int i = x-1; i &gt; y; i -= lowbit(i)) BITS[x] ^= BITS[i]; &#125; &#125;void update(int x,int val)&#123; for(int i=x;i&lt;=N;i+=lowbit(i)) BITS[i]^=val;&#125;int main()&#123; _ cin&gt;&gt;N&gt;&gt;Q; for(int i=1;i&lt;=N;i++) cin&gt;&gt;Origin[i]; init(N); while(Q--)&#123; int choice,x,y; cin&gt;&gt;choice&gt;&gt;x&gt;&gt;y; if(choice==0)&#123; cout&lt;&lt;(xxor(y)^xxor(x-1))&lt;&lt;'\\n'; &#125; else&#123; int OO=Origin[x]^y; Origin[x]=y; update(x,OO); &#125; &#125; return 0;&#125; 後記 Afterword每次做到有關 XOR 的題型都讓我想到有一題原本 時間 $O(N\\log{N})$ 空間 $O(N)$最後複雜度可以壓在 時間 $O(N)$ 空間 $O(1)$下一篇就來寫這題的報告書","categories":[{"name":"解題區","slug":"解題區","permalink":"http://blog.yangjerry.tw/categories/解題區/"},{"name":"解題報告書 - ZeroJudge","slug":"解題區/解題報告書-ZeroJudge","permalink":"http://blog.yangjerry.tw/categories/解題區/解題報告書-ZeroJudge/"}],"tags":[{"name":"XOR","slug":"XOR","permalink":"http://blog.yangjerry.tw/tags/XOR/"},{"name":"Fenwick Tree","slug":"Fenwick-Tree","permalink":"http://blog.yangjerry.tw/tags/Fenwick-Tree/"},{"name":"Binary Index Tree","slug":"Binary-Index-Tree","permalink":"http://blog.yangjerry.tw/tags/Binary-Index-Tree/"}]},{"title":"c453. TOI2003 第二題：疊羅漢","slug":"zj-c453","date":"2018-08-31T07:29:57.000Z","updated":"2018-09-02T04:42:34.820Z","comments":true,"path":"2018/08/31/zj-c453/","link":"","permalink":"http://blog.yangjerry.tw/2018/08/31/zj-c453/","excerpt":"題目 Problem題目連結：https://zerojudge.tw/ShowProblem?problemid=c453","text":"題目 Problem題目連結：https://zerojudge.tw/ShowProblem?problemid=c453 敘述 Description 某特技團經常表演疊羅漢的節目。表演時通常在最底層會先站好一排連續的 n 個人，然後在任意連續兩人的肩膀上面便可支撐另一個人站在這兩個人的上一層。在第二層如果有連續兩人的話，當然可繼續往第三層疊上一個人，以此類推。為了增加趣味性，有時會組合出不同的型態展現在觀眾的眼前。舉例來說，如果 n=3，也就是說底層共有 3 個人，那麼就有下列 5 種不同的組合。 如果 n=4，也就是說底層共有 4 個人，那麼你也可以列舉一下，便可知道共有下列 14 種不同的組合。現在針對不同的 n 值，請你撰寫一個程式來計算共有幾種不同的組合？ 輸入 Input第一行有一個正整數 n，1 ≤ n ≤ 20。 輸出 Output請輸出共有幾種不同的組合。 範例輸入 Sample Input12345//範例輸入一3//範例輸入二4 範例輸出 Sample Output12345//範例輸出一5//範例輸出二14 提示 Hint題解 Solution動態規劃 Dynamic Programming感覺這題很DP，不過 oToToT 大大真的寫出了 DP 算式： 令$dp[i][j]$代表第$i$斜排他的長度要是$j$時的方法數$dp[i][j]=\\sum_{k=j-1}^{i-1}dp[i-1][k]$因為會發現若是這裡要擺長度為$j$那前面最少要擺長度$j-1$，所以可以枚舉前一斜條擺放的數量來計算這個狀態的方法數。而對於n個斜條的總方法數，只要再枚舉最後一斜條有幾個人就好了。 我果然很低端，回我的當下我真的看不懂QQ 卡特蘭數 Catalan Number（至於為何會想到卡特蘭數，請滑到後記）這是我理解的版本，連結 $C(0,0)=1$$C(1,1)=C(0,0)$$C(2,2)=C(1,0)+C(1,1)$$C(3,3)=C(2,0)+C(2,1)+C(2,2)$$C(4,4)=C(3,0)+C(3,1)+C(3,2)+C(3,3)$…$C(N,N)=C(N-1,0)+C(N-1,1)+…+C(N-1,N-1)$ 可以把這些想像成 $N$層上面$N-1-0$層有幾種組合$N$層上面$N-1-1$層有幾種組合…$N$層上面$N-1-i$層有幾種組合…$N$層上面$1$層有幾種組合$N$層上面$0$層有幾種組合再加上 涂家銘 大大提供給我參考的圖：稍微轉一轉是不是就變成高中熟悉的最短路徑組合呢？ 程式碼 Accepted Code123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;#define _ ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);using namespace std;long long int catalan(long long int N)&#123; long long int n2=2*N; long long int ans=1; for(long long int i=N+1;i&lt;=n2;i++)&#123; ans*=i; ans/=(i-N); &#125; ans/=(N+1); return ans;&#125;int main()&#123; _ long long int query[21]=&#123;0,1&#125;; for(long long int i=1;i&lt;21;i++)&#123; query[i]=catalan(i); &#125; int N; cin&gt;&gt;N; cout&lt;&lt;query[N]&lt;&lt;'\\n'; return 0;&#125; 後記 Afterword這題我一開始打開 Google 搜尋「0 1 2 5 14 OEIS」（我認為0位是0種，所以一開始打0）作弊開好開滿但沒想到一打開就是傳說中的卡特蘭數列只有聽到「清大程式解題營」的 旺陽學長 提到過但沒有寫過這種題目 不過 涂家銘 大大表示： 幫社團出練習賽題目其中一題用 DP 做會 TLE（練習賽也太狠了吧QQ） 的確，畢竟這題的最大值$N=20$，如果$N$更大，有機會爆 TLE 了","categories":[{"name":"解題區","slug":"解題區","permalink":"http://blog.yangjerry.tw/categories/解題區/"},{"name":"解題報告書 - ZeroJudge","slug":"解題區/解題報告書-ZeroJudge","permalink":"http://blog.yangjerry.tw/categories/解題區/解題報告書-ZeroJudge/"}],"tags":[{"name":"建表","slug":"建表","permalink":"http://blog.yangjerry.tw/tags/建表/"},{"name":"卡特蘭數","slug":"卡特蘭數","permalink":"http://blog.yangjerry.tw/tags/卡特蘭數/"}]},{"title":"a625. 5. Overhanging Cards","slug":"zj-a625","date":"2018-08-30T12:04:05.000Z","updated":"2018-08-30T14:42:38.454Z","comments":true,"path":"2018/08/30/zj-a625/","link":"","permalink":"http://blog.yangjerry.tw/2018/08/30/zj-a625/","excerpt":"題目 Problem題目連結：https://zerojudge.tw/ShowProblem?problemid=a625","text":"題目 Problem題目連結：https://zerojudge.tw/ShowProblem?problemid=a625 敘述 Description你可以把一疊的卡片凸出桌子的邊緣多遠呢？如果你有一張卡，你最大可以凸出卡片長度的一半。有兩張卡時，你可以把上面那張的一半凸出下面的那張，而下面的那張則有三分之一凸出桌子的邊緣，總凸出長度則為$ 1/2 + 1/3 = 5/6 $張卡片長度。總之，你可以把$ n $張卡片凸出$ 1/2 + 1/3 + 1/4 + … + 1/(n+1) $張卡片的長度，其中最上面那張凸出$ 1/2 $於第二張的外面，第二張凸出$ 1/3 $於第三張的外面，第三張凸出$ 1/4$，以此類推，最底下那張則凸出$ 1/(n+1)$。如下圖所示。 輸入 Input每筆測資一行，含有一個正浮點數 c (代表所要凸出的總長度)，其值最小為 0.01，最大為 5.20；這個數含有三位數字。 輸出 Output輸出要達成所需的凸出長度最少需要幾張卡片。請參照範例輸出的格式。 範例輸入 Sample Input12341.003.710.045.19 範例輸出 Sample Output12343 card(s)61 card(s)1 card(s)273 card(s) 提示 Hint題解 Solution$1$張卡片長度為$1/2$$2$張卡片長度為$1/2+1/3$$3$張卡片長度為$1/2+1/3+1/4$$…$以此類推$…$$n$張卡片長度為$1/2+1/3+1/4+…+1/(n+1)$先建表，最大卡片數頂多$276$張最後再用二分搜尋找卡片數就好 程式碼 Accepted Code1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#define _ ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);using namespace std;int main()&#123; _ double query[277]=&#123;0&#125;,a=0.0; for(int i=1;a&lt;=5.20;i++)&#123; a+=(1.0/(i+1)); query[i]=a; &#125; double enter; while(cin&gt;&gt;enter)&#123; int l=0,r=277; while(l+1&lt;r)&#123; int mid=(l+r)/2; if(enter&gt;query[mid])&#123; l=mid; &#125; else&#123; r=mid; &#125; &#125; cout&lt;&lt;l+1&lt;&lt;\" card(s)\"&lt;&lt;'\\n'; &#125; return 0;&#125; 後記 Afterword這一題在 ICPC Live Archive 跟 POJ 找得到ICPC Live Archive 題目代碼：2294 - HangoverPOJ 題目代碼：1003 - HangoverZeroJudge 拿到 AC 之後就到 ICPC Live Archive 繳交，但直接被 WA 掉我還以為是我二分搜寫錯但仔細看了它們的 Input 後才知道程式輸入$0.00$才會結束改完這題就 AC 了","categories":[{"name":"解題區","slug":"解題區","permalink":"http://blog.yangjerry.tw/categories/解題區/"},{"name":"解題報告書 - ZeroJudge","slug":"解題區/解題報告書-ZeroJudge","permalink":"http://blog.yangjerry.tw/categories/解題區/解題報告書-ZeroJudge/"}],"tags":[{"name":"建表","slug":"建表","permalink":"http://blog.yangjerry.tw/tags/建表/"},{"name":"二分搜","slug":"二分搜","permalink":"http://blog.yangjerry.tw/tags/二分搜/"}]},{"title":"c700. 壞掉的隊列(queue)","slug":"zj-c700","date":"2018-08-29T13:34:05.000Z","updated":"2018-08-29T16:29:27.752Z","comments":true,"path":"2018/08/29/zj-c700/","link":"","permalink":"http://blog.yangjerry.tw/2018/08/29/zj-c700/","excerpt":"題目 Problem題目連結：https://www.zerojudge.tw/ShowProblem?problemid=c700","text":"題目 Problem題目連結：https://www.zerojudge.tw/ShowProblem?problemid=c700 敘述 Description「測資中有若干行輸入，請你實作 queue 的幾種操作： push $X(0≤X&lt;2^{32})$: 將 $X$ 加入隊列 pop: 輸出隊列最前方的數字並刪除，你可以假設此時隊列不是空的」 小W本來想隨便寫寫交差了事，卻發現 STL 的 queue 壞了！ 再看看題目，原來底下附註一行小字：請用兩個 stack 完成這題。 於是小W希望你能用以下代號寫一張紙條告訴他該怎麼做。 1: 讀入 push X 並將 X 放到堆疊一 2: 讀入 push X 並將 X 放到堆疊二 3: 讀入 pop ，將堆疊一頂端的元素輸出並刪除 4: 讀入 pop ，將堆疊二頂端的元素輸出並刪除 5: 將堆疊一頂端的元素取出並放至堆疊二 6: 將堆疊二頂端的元素取出並放至堆疊一 如果取出元素時堆疊為空或者讀入 push/pop 的順序與輸入測資不符，你會害小W拿到一個WA。 輸入 Input見題目和範例。 輸出 Output輸出一行你要傳給小W的內容。 範例輸入 Sample Input1234push 111push 222poppop 範例輸出 Sample Output1234567891011121314範例輸出一:1234範例輸出二:12544範例輸出三:1143範例輸出四:1313範例輸出五:1133 提示 Hint輸入至多 100000 行。 以範例輸入而言，範例輸出一、二會拿到AC。 範例輸出三會拿到WA，因為操作4時堆疊二是空的。 範例輸出四也會拿到WA，因為輸入順序是push-&gt;push-&gt;pop-&gt;pop，但是1313的操作分別為push-&gt;pop-&gt;push-&gt;pop。 範例輸出五的操作過程完全合法，但依據先進先出的原則，111應該比222早離開queue，若以1133的方式操作，222將比111早輸出，所以會拿到WA。 題解 Solution第一篇解題報告書就給這題啦！ Hackerrank 可以找到這個問題（這題就是要強制你使用 Stack）實作 Queue 需要用到兩個 Stack分別命名為$S1$跟$S2$ $S1$用來記錄輸入的東西$S2$就是把$S1$的內容顛倒過來 $push$的時候先放入$S1$裡面$pop$的時候先檢查$S2$有沒有東西 如果有，$S2$的頂端$pop$掉如果沒有，先$S1$所有內容$pop$到$S2$，再讓$S2$的頂端$pop$掉 了解怎麼用 Stack 實作 Queue 就可以回到這題 依照上面的做法，可以使用代號$1,4,5$的組合或$2,3,6$的組合來完成這題並且用$2$個整數紀錄$2$個 Stack 的內容數量分別命名為$x_1$跟$x_2$ 如果要$push$，就輸出$1$，把$x_1+1$如果要$pop$，就先檢查$x_2$是否大於$0$ 如果有，就輸出$4$，把$x_2-1$如果沒有，先輸出$x_1$個$5$，讓$x_2$加上$x_1$，並且把$x_1$歸零，再輸出$4$，把$x_2-1$ 這樣就可以來寫 Code 啦！ 程式碼 Accepted Code12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define _ ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);using namespace std;int main()&#123; _ string enter; int total1=0,total2=0; while(cin&gt;&gt;enter)&#123; if(enter==\"push\")&#123; long long int a; cin&gt;&gt;a; total1++; cout&lt;&lt;1; &#125; else&#123; if(total2)&#123; cout&lt;&lt;4; total2--; &#125; else&#123; for(int i=0;i&lt;total1;i++)&#123; cout&lt;&lt;5; &#125; total2+=total1; if(total2)&#123; cout&lt;&lt;4; total2--; &#125; total1=0; &#125; &#125; &#125; return 0;&#125; 後記 Afterword這題有沒有其他解法？這題是 Special Judge，應該是有吧，但……我沒有想到上面這個解法是算簡單啦如果有更好的解法，我還會再寫上去啦！","categories":[{"name":"解題區","slug":"解題區","permalink":"http://blog.yangjerry.tw/categories/解題區/"},{"name":"解題報告書 - ZeroJudge","slug":"解題區/解題報告書-ZeroJudge","permalink":"http://blog.yangjerry.tw/categories/解題區/解題報告書-ZeroJudge/"}],"tags":[{"name":"Stack","slug":"Stack","permalink":"http://blog.yangjerry.tw/tags/Stack/"},{"name":"Queue","slug":"Queue","permalink":"http://blog.yangjerry.tw/tags/Queue/"},{"name":"Special Judge","slug":"Special-Judge","permalink":"http://blog.yangjerry.tw/tags/Special-Judge/"}]},{"title":"Hello Hexo! Test By Jerry Yang","slug":"hello-world","date":"2018-08-26T06:30:49.123Z","updated":"2018-08-30T14:43:25.866Z","comments":true,"path":"2018/08/26/hello-world/","link":"","permalink":"http://blog.yangjerry.tw/2018/08/26/hello-world/","excerpt":"先恭喜亞運台灣 🇹🇼 奪得金牌網路中文 也很大方的免費讓人註冊.tw","text":"先恭喜亞運台灣 🇹🇼 奪得金牌網路中文 也很大方的免費讓人註冊.tw於是，這個 Blog 就誕生了第一次用 Hexo 架設用 Markdown 來寫寫看瑣碎事 首頁嘛……晚點再把坑補上寫到這裡就這樣吧！之後再補","categories":[{"name":"Hello World","slug":"Hello-World","permalink":"http://blog.yangjerry.tw/categories/Hello-World/"}],"tags":[]}]}